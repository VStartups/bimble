use crate::{
    gens::{func::p_fn, pin::pin, print::p_print, var::pvar},
    tokens::{TokenList, Tokens},
};
use std::process::exit;
#[allow(unused)]
pub fn gen_token(code: &str) -> TokenList {
    let mut tl = TokenList::new();
    let mut index = 1;
    let mut vrs: Vec<(String, i32)> = Vec::new();
    let mut flist: Vec<String> = Vec::new(); // List of defined functions
    let mut fcds = String::new();
    let mut infn = false; // Track if inside a function
    let mut undefined_fn_calls: Vec<(String, usize, String)> = Vec::new(); // Store undefined function names with line index and full line
    let mut function_calls: Vec<(String, usize, String)> = Vec::new(); // Store function calls for processing later

    for line in code.lines() {
        let line = line.trim();

        if line.is_empty() {
            index += 1;
            continue;
        }

        // Handle echoln
        if line.starts_with("echoln(\"") && line.ends_with("\")") && !infn {
            let ptxt = p_print(line, &tl);
            tl.push(Tokens::Print(ptxt.clone()));
        }
        // Handle variable definition (may)
        else if line.starts_with("may ") {
            let (name, var, usename) = pvar(line, &mut vrs);
            tl.push(Tokens::Variable(name.clone(), var.clone(), usename.clone()));
        }
        // Handle takein
        else if line.starts_with("takein(") && line.ends_with(")") && !infn {
            let g = pin(line, &tl);
            if !g.0 {
                eprintln!(
                    "Error: Variable '{}' used in takein statement is not defined. Line {}: '{}'",
                    g.1, index, line
                );
                exit(1);
            }
            tl.push(Tokens::Takein(g.1.clone()));
        }
        // Handle function definition
        else if line.starts_with("ON ") && line.ends_with("{") {
            infn = true;
            fcds.push_str(format!("\n{}", line).as_str());
        }
        // If inside a function body
        else if infn {
            fcds.push_str(format!("\n{}", line).as_str());
            if line.trim() == "}" {
                infn = false;
                let fpr = p_fn(&fcds, &mut vrs, &mut index);
                // Handle the flist mutation after p_fn
                flist.extend_from_slice(&fpr.2);
                println!("Function list after p_fn: {:?}", flist); // Debug: Print function list after p_fn
                println!("fpr : {:?}",fpr);
                tl.join_mut(fpr.1); // Join the tokens generated by p_fn
                fcds.clear(); // Clear the function body buffer
            }
        }
        // Accumulate function calls
        else {
            let trimmed_line = line.trim();
            println!("Trimmed line: '{}'", trimmed_line); // Debug: Print the trimmed line
            if !trimmed_line.is_empty() {
                let fn_name = trimmed_line.split('(').next().unwrap_or("").to_string(); // Extract function name
                println!("Function name extracted: '{}'", fn_name); // Debug: Print the extracted function name
                println!("Function list before checking: {:?}", flist); // Debug: Print flist before checking function calls

                if !fn_name.is_empty() {
                    function_calls.push((fn_name, index as usize, line.to_string()));
                }
            }
        }
        index += 1;
    }

    // Process function calls after all other code
    let mut notfound = false;
    for (fn_name, line_index, full_line) in function_calls {
        let mut found = false;

        // Check if the function exists in the function list (flist)
        for i in &flist {
            println!("Checking if function call '{}' is in the list, comparing with '{}'", fn_name, i); // Debug: Print checking function call
            if *i == fn_name {
                found = true;
                break;
            }
        }

        // If the function is not found in the function list, report an error
        if !found {
            eprintln!(
                "Error: Undefined function call '{}' at line {}: '{}'",
                fn_name, line_index, full_line
            );
            notfound = true;
        } else {
            tl.push(Tokens::FnCall(fn_name)); // Add FnCall token if function is defined
        }
    }

    // Exit if undefined functions were found
    if notfound {
        exit(1);
    }

    println!("[DEBUG] Token generation complete.");
    tl
}
